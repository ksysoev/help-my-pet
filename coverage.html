
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>help-my-pet: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ksysoev/help-my-pet/cmd/help-my-pet/main.go (0.0%)</option>
				
				<option value="file1">github.com/ksysoev/help-my-pet/pkg/bot/ai_provider_mock.go (67.9%)</option>
				
				<option value="file2">github.com/ksysoev/help-my-pet/pkg/bot/bot_api_mock.go (61.1%)</option>
				
				<option value="file3">github.com/ksysoev/help-my-pet/pkg/bot/service.go (100.0%)</option>
				
				<option value="file4">github.com/ksysoev/help-my-pet/pkg/cmd/config.go (87.0%)</option>
				
				<option value="file5">github.com/ksysoev/help-my-pet/pkg/cmd/init.go (100.0%)</option>
				
				<option value="file6">github.com/ksysoev/help-my-pet/pkg/cmd/logger.go (100.0%)</option>
				
				<option value="file7">github.com/ksysoev/help-my-pet/pkg/cmd/mock_bot_service.go (100.0%)</option>
				
				<option value="file8">github.com/ksysoev/help-my-pet/pkg/core/ai_service.go (100.0%)</option>
				
				<option value="file9">github.com/ksysoev/help-my-pet/pkg/core/llm_mock.go (65.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log/slog"
        "os"
        "os/signal"
        "syscall"

        "github.com/ksysoev/help-my-pet/pkg/cmd"
)

// version is the version of the application. It should be set at build time.
var version = "dev"

func main() <span class="cov0" title="0">{
        ctx, _ := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)

        rootCmd := cmd.InitCommands(version)

        if err := rootCmd.ExecuteContext(ctx); err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to execute command", slog.Any("error", err))
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by mockery v2.50.2. DO NOT EDIT.

//go:build !compile

package bot

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockAIProvider is an autogenerated mock type for the AIProvider type
type MockAIProvider struct {
        mock.Mock
}

type MockAIProvider_Expecter struct {
        mock *mock.Mock
}

func (_m *MockAIProvider) EXPECT() *MockAIProvider_Expecter <span class="cov8" title="1">{
        return &amp;MockAIProvider_Expecter{mock: &amp;_m.Mock}
}</span>

// GetPetAdvice provides a mock function with given fields: ctx, question
func (_m *MockAIProvider) GetPetAdvice(ctx context.Context, question string) (string, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, question)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPetAdvice")</span>
        }

        <span class="cov8" title="1">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, question)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, question)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, question)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// MockAIProvider_GetPetAdvice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPetAdvice'
type MockAIProvider_GetPetAdvice_Call struct {
        *mock.Call
}

// GetPetAdvice is a helper method to define mock.On call
//   - ctx context.Context
//   - question string
func (_e *MockAIProvider_Expecter) GetPetAdvice(ctx interface{}, question interface{}) *MockAIProvider_GetPetAdvice_Call <span class="cov8" title="1">{
        return &amp;MockAIProvider_GetPetAdvice_Call{Call: _e.mock.On("GetPetAdvice", ctx, question)}
}</span>

func (_c *MockAIProvider_GetPetAdvice_Call) Run(run func(ctx context.Context, question string)) *MockAIProvider_GetPetAdvice_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockAIProvider_GetPetAdvice_Call) Return(_a0 string, _a1 error) *MockAIProvider_GetPetAdvice_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockAIProvider_GetPetAdvice_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockAIProvider_GetPetAdvice_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockAIProvider creates a new instance of MockAIProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAIProvider(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockAIProvider <span class="cov8" title="1">{
        mock := &amp;MockAIProvider{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by mockery v2.50.2. DO NOT EDIT.

//go:build !compile

package bot

import (
        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
        mock "github.com/stretchr/testify/mock"
)

// MockBotAPI is an autogenerated mock type for the BotAPI type
type MockBotAPI struct {
        mock.Mock
}

type MockBotAPI_Expecter struct {
        mock *mock.Mock
}

func (_m *MockBotAPI) EXPECT() *MockBotAPI_Expecter <span class="cov8" title="1">{
        return &amp;MockBotAPI_Expecter{mock: &amp;_m.Mock}
}</span>

// GetUpdatesChan provides a mock function with given fields: config
func (_m *MockBotAPI) GetUpdatesChan(config tgbotapi.UpdateConfig) tgbotapi.UpdatesChannel <span class="cov8" title="1">{
        ret := _m.Called(config)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUpdatesChan")</span>
        }

        <span class="cov8" title="1">var r0 tgbotapi.UpdatesChannel
        if rf, ok := ret.Get(0).(func(tgbotapi.UpdateConfig) tgbotapi.UpdatesChannel); ok </span><span class="cov0" title="0">{
                r0 = rf(config)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(tgbotapi.UpdatesChannel)
                }</span>
        }

        <span class="cov8" title="1">return r0</span>
}

// MockBotAPI_GetUpdatesChan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUpdatesChan'
type MockBotAPI_GetUpdatesChan_Call struct {
        *mock.Call
}

// GetUpdatesChan is a helper method to define mock.On call
//   - config tgbotapi.UpdateConfig
func (_e *MockBotAPI_Expecter) GetUpdatesChan(config interface{}) *MockBotAPI_GetUpdatesChan_Call <span class="cov8" title="1">{
        return &amp;MockBotAPI_GetUpdatesChan_Call{Call: _e.mock.On("GetUpdatesChan", config)}
}</span>

func (_c *MockBotAPI_GetUpdatesChan_Call) Run(run func(config tgbotapi.UpdateConfig)) *MockBotAPI_GetUpdatesChan_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(tgbotapi.UpdateConfig))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockBotAPI_GetUpdatesChan_Call) Return(_a0 tgbotapi.UpdatesChannel) *MockBotAPI_GetUpdatesChan_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockBotAPI_GetUpdatesChan_Call) RunAndReturn(run func(tgbotapi.UpdateConfig) tgbotapi.UpdatesChannel) *MockBotAPI_GetUpdatesChan_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Send provides a mock function with given fields: c
func (_m *MockBotAPI) Send(c tgbotapi.Chattable) (tgbotapi.Message, error) <span class="cov8" title="1">{
        ret := _m.Called(c)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Send")</span>
        }

        <span class="cov8" title="1">var r0 tgbotapi.Message
        var r1 error
        if rf, ok := ret.Get(0).(func(tgbotapi.Chattable) (tgbotapi.Message, error)); ok </span><span class="cov0" title="0">{
                return rf(c)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(tgbotapi.Chattable) tgbotapi.Message); ok </span><span class="cov0" title="0">{
                r0 = rf(c)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(tgbotapi.Message)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(tgbotapi.Chattable) error); ok </span><span class="cov0" title="0">{
                r1 = rf(c)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// MockBotAPI_Send_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Send'
type MockBotAPI_Send_Call struct {
        *mock.Call
}

// Send is a helper method to define mock.On call
//   - c tgbotapi.Chattable
func (_e *MockBotAPI_Expecter) Send(c interface{}) *MockBotAPI_Send_Call <span class="cov8" title="1">{
        return &amp;MockBotAPI_Send_Call{Call: _e.mock.On("Send", c)}
}</span>

func (_c *MockBotAPI_Send_Call) Run(run func(c tgbotapi.Chattable)) *MockBotAPI_Send_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(tgbotapi.Chattable))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockBotAPI_Send_Call) Return(_a0 tgbotapi.Message, _a1 error) *MockBotAPI_Send_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockBotAPI_Send_Call) RunAndReturn(run func(tgbotapi.Chattable) (tgbotapi.Message, error)) *MockBotAPI_Send_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// StopReceivingUpdates provides a mock function with no fields
func (_m *MockBotAPI) StopReceivingUpdates() <span class="cov8" title="1">{
        _m.Called()
}</span>

// MockBotAPI_StopReceivingUpdates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopReceivingUpdates'
type MockBotAPI_StopReceivingUpdates_Call struct {
        *mock.Call
}

// StopReceivingUpdates is a helper method to define mock.On call
func (_e *MockBotAPI_Expecter) StopReceivingUpdates() *MockBotAPI_StopReceivingUpdates_Call <span class="cov8" title="1">{
        return &amp;MockBotAPI_StopReceivingUpdates_Call{Call: _e.mock.On("StopReceivingUpdates")}
}</span>

func (_c *MockBotAPI_StopReceivingUpdates_Call) Run(run func()) *MockBotAPI_StopReceivingUpdates_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockBotAPI_StopReceivingUpdates_Call) Return() *MockBotAPI_StopReceivingUpdates_Call <span class="cov8" title="1">{
        _c.Call.Return()
        return _c
}</span>

func (_c *MockBotAPI_StopReceivingUpdates_Call) RunAndReturn(run func()) *MockBotAPI_StopReceivingUpdates_Call <span class="cov0" title="0">{
        _c.Run(run)
        return _c
}</span>

// NewMockBotAPI creates a new instance of MockBotAPI. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBotAPI(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockBotAPI <span class="cov8" title="1">{
        mock := &amp;MockBotAPI{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package bot

import (
        "context"
        "fmt"
        "log/slog"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

type AIProvider interface {
        GetPetAdvice(ctx context.Context, question string) (string, error)
}

type Service struct {
        bot   BotAPI
        aiSvc AIProvider
}

type BotAPIFactory func(token string) (BotAPI, error)

func defaultBotAPIFactory(token string) (BotAPI, error) <span class="cov8" title="1">{
        return tgbotapi.NewBotAPI(token)
}</span>

func NewService(token string, aiSvc AIProvider) *Service <span class="cov8" title="1">{
        return NewServiceWithFactory(token, aiSvc, defaultBotAPIFactory)
}</span>

func NewServiceWithFactory(token string, aiSvc AIProvider, factory BotAPIFactory) *Service <span class="cov8" title="1">{
        bot, err := factory(token)
        if err != nil </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("Failed to create Telegram bot: %v", err))</span>
        }

        <span class="cov8" title="1">return NewServiceWithBot(bot, aiSvc)</span>
}

func NewServiceWithBot(bot BotAPI, aiSvc AIProvider) *Service <span class="cov8" title="1">{
        return &amp;Service{
                bot:   bot,
                aiSvc: aiSvc,
        }
}</span>

func (s *Service) Run(ctx context.Context) error <span class="cov8" title="1">{
        slog.Info("Starting Telegram bot")

        updateConfig := tgbotapi.NewUpdate(0)
        updateConfig.Timeout = 30

        updates := s.bot.GetUpdatesChan(updateConfig)

        for </span><span class="cov8" title="1">{
                select </span>{
                case update := &lt;-updates:<span class="cov8" title="1">
                        if update.Message == nil </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">go s.handleMessage(ctx, update.Message)</span>

                case &lt;-ctx.Done():<span class="cov8" title="1">
                        slog.Info("Shutting down bot")
                        s.bot.StopReceivingUpdates()
                        return nil</span>
                }
        }
}

func (s *Service) handleMessage(ctx context.Context, message *tgbotapi.Message) <span class="cov8" title="1">{
        slog.Info("Received message",
                slog.Int64("chat_id", message.Chat.ID),
                slog.String("text", message.Text),
        )

        if message.Text == "" </span><span class="cov8" title="1">{
                return
        }</span>

        // Send typing action
        <span class="cov8" title="1">typing := tgbotapi.NewChatAction(message.Chat.ID, tgbotapi.ChatTyping)
        s.bot.Send(typing)

        // Get AI response
        response, err := s.aiSvc.GetPetAdvice(ctx, message.Text)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Failed to get AI response",
                        slog.Any("error", err),
                        slog.Int64("chat_id", message.Chat.ID),
                )
                s.sendErrorMessage(message.Chat.ID)
                return
        }</span>

        // Send response
        <span class="cov8" title="1">msg := tgbotapi.NewMessage(message.Chat.ID, response)
        msg.ReplyToMessageID = message.MessageID

        if _, err := s.bot.Send(msg); err != nil </span><span class="cov8" title="1">{
                slog.Error("Failed to send message",
                        slog.Any("error", err),
                        slog.Int64("chat_id", message.Chat.ID),
                )
        }</span>
}

func (s *Service) sendErrorMessage(chatID int64) <span class="cov8" title="1">{
        msg := tgbotapi.NewMessage(chatID, "Sorry, I encountered an error while processing your request. Please try again later.")
        s.bot.Send(msg)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "context"
        "fmt"
        "log/slog"
        "strings"

        "github.com/ksysoev/help-my-pet/pkg/bot"
        "github.com/ksysoev/help-my-pet/pkg/core"
        "github.com/spf13/viper"
)

type Config struct {
        Bot struct {
                TelegramToken string `mapstructure:"telegram_token"`
        } `mapstructure:"bot"`
        AI struct {
                AnthropicKey string `mapstructure:"anthropic_key"`
                Model        string `mapstructure:"model"`
        } `mapstructure:"ai"`
}

// initConfig initializes the configuration by reading from the specified config file.
func initConfig(arg *args) (*Config, error) <span class="cov8" title="1">{
        v := viper.New()

        // Set default values
        v.SetDefault("ai.model", "claude-2")

        if arg.ConfigPath != "" </span><span class="cov8" title="1">{
                v.SetConfigFile(arg.ConfigPath)
                if err := v.ReadInConfig(); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to read config: %w", err)
                }</span>
        }

        <span class="cov8" title="1">var cfg Config

        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        v.AutomaticEnv()

        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if cfg.Bot.TelegramToken == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("telegram token is required")
        }</span>
        <span class="cov8" title="1">if cfg.AI.AnthropicKey == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("anthropic key is required")
        }</span>

        <span class="cov8" title="1">slog.Debug("Config loaded", slog.Any("config", cfg))

        return &amp;cfg, nil</span>
}

type BotServiceFactory func(token string, aiSvc *core.AIService) BotService

type BotService interface {
        Run(ctx context.Context) error
}

// defaultBotServiceFactory creates a real bot service
func defaultBotServiceFactory(token string, aiSvc *core.AIService) BotService <span class="cov0" title="0">{
        return bot.NewService(token, aiSvc)
}</span>

// runBotFunc is the function type for running the bot
type runBotFunc func(ctx context.Context, cfg *Config, factory BotServiceFactory) error

// runBot is the default implementation
var runBot runBotFunc = func(ctx context.Context, cfg *Config, factory BotServiceFactory) error <span class="cov8" title="1">{
        if factory == nil </span><span class="cov0" title="0">{
                factory = defaultBotServiceFactory
        }</span>

        <span class="cov8" title="1">aiService := core.NewAIService(cfg.AI.AnthropicKey, cfg.AI.Model)
        botService := factory(cfg.Bot.TelegramToken, aiService)

        return botService.Run(ctx)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "log/slog"

        "github.com/spf13/cobra"
)

type args struct {
        version    string
        LogLevel   string
        ConfigPath string
        TextFormat bool
}

// InitCommands initializes and returns the root command for the application.
func InitCommands(version string) *cobra.Command <span class="cov8" title="1">{
        args := &amp;args{
                version: version,
        }

        cmd := &amp;cobra.Command{
                Use:   "help-my-pet",
                Short: "AI-powered Telegram bot for pet health assistance",
                Long:  "A Telegram bot that uses Anthropic AI to help pet owners with health-related questions about their pets",
        }

        cmd.AddCommand(BotCommand(args))

        cmd.PersistentFlags().StringVar(&amp;args.ConfigPath, "config", "", "config file path")
        cmd.PersistentFlags().StringVar(&amp;args.LogLevel, "loglevel", "info", "log level (debug, info, warn, error)")
        cmd.PersistentFlags().BoolVar(&amp;args.TextFormat, "logtext", false, "log in text format, otherwise JSON")

        return cmd
}</span>

// BotCommand creates a new cobra.Command to start the Telegram bot server.
func BotCommand(arg *args) *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:   "bot",
                Short: "Start the Telegram bot server",
                Long:  "Start the AI-powered Telegram bot server for pet health assistance",
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov8" title="1">{
                        if err := initLogger(arg); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">slog.Info("Starting Help My Pet bot", slog.String("version", arg.version))

                        cfg, err := initConfig(arg)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">return runBot(cmd.Context(), cfg, nil)</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "log/slog"
        "os"
)

// initLogger initializes the default logger for the application using slog.
func initLogger(arg *args) error <span class="cov8" title="1">{
        var logLevel slog.Level
        if err := logLevel.UnmarshalText([]byte(arg.LogLevel)); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">options := &amp;slog.HandlerOptions{
                Level: logLevel,
        }

        var logHandler slog.Handler
        if arg.TextFormat </span><span class="cov8" title="1">{
                logHandler = slog.NewTextHandler(os.Stdout, options)
        }</span> else<span class="cov8" title="1"> {
                logHandler = slog.NewJSONHandler(os.Stdout, options)
        }</span>

        <span class="cov8" title="1">logger := slog.New(logHandler).With(
                slog.String("ver", arg.version),
                slog.String("app", "help-my-pet"),
        )

        slog.SetDefault(logger)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cmd

import (
        "context"

        "github.com/stretchr/testify/mock"
)

type MockBotService struct {
        mock.Mock
}

func (m *MockBotService) Run(ctx context.Context) error <span class="cov8" title="1">{
        args := m.Called(ctx)
        return args.Error(0)
}</span>

func NewMockBotService() *MockBotService <span class="cov8" title="1">{
        return &amp;MockBotService{}
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package core

import (
        "context"
        "fmt"

        "github.com/tmc/langchaingo/llms"
        "github.com/tmc/langchaingo/llms/anthropic"
)

type AIService struct {
        llm   LLM
        model string
}

func NewAIService(apiKey, model string) *AIService <span class="cov8" title="1">{
        llm, err := anthropic.New(anthropic.WithToken(apiKey))
        if err != nil </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("Failed to initialize Anthropic LLM: %v", err))</span>
        }

        <span class="cov8" title="1">return &amp;AIService{
                model: model,
                llm:   llm,
        }</span>
}

func (s *AIService) GetPetAdvice(ctx context.Context, question string) (string, error) <span class="cov8" title="1">{
        prompt := fmt.Sprintf(`You are a helpful veterinary AI assistant. Please provide accurate, helpful, and compassionate advice for the following pet-related question. If the question involves a serious medical condition, always recommend consulting with a veterinarian.

Question: %s

Please provide a clear and informative response:`, question)

        completion, err := s.llm.Call(ctx, prompt,
                llms.WithModel(s.model),
                llms.WithMaxTokens(1000),
        )
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to get AI response: %w", err)
        }</span>

        <span class="cov8" title="1">return completion, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by mockery v2.50.2. DO NOT EDIT.

//go:build !compile

package core

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
        llms "github.com/tmc/langchaingo/llms"
)

// MockLLM is an autogenerated mock type for the LLM type
type MockLLM struct {
        mock.Mock
}

type MockLLM_Expecter struct {
        mock *mock.Mock
}

func (_m *MockLLM) EXPECT() *MockLLM_Expecter <span class="cov8" title="1">{
        return &amp;MockLLM_Expecter{mock: &amp;_m.Mock}
}</span>

// Call provides a mock function with given fields: ctx, prompt, options
func (_m *MockLLM) Call(ctx context.Context, prompt string, options ...llms.CallOption) (string, error) <span class="cov8" title="1">{
        _va := make([]interface{}, len(options))
        for _i := range options </span><span class="cov8" title="1">{
                _va[_i] = options[_i]
        }</span>
        <span class="cov8" title="1">var _ca []interface{}
        _ca = append(_ca, ctx, prompt)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Call")</span>
        }

        <span class="cov8" title="1">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, ...llms.CallOption) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, prompt, options...)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, ...llms.CallOption) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, prompt, options...)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, ...llms.CallOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, prompt, options...)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// MockLLM_Call_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Call'
type MockLLM_Call_Call struct {
        *mock.Call
}

// Call is a helper method to define mock.On call
//   - ctx context.Context
//   - prompt string
//   - options ...llms.CallOption
func (_e *MockLLM_Expecter) Call(ctx interface{}, prompt interface{}, options ...interface{}) *MockLLM_Call_Call <span class="cov8" title="1">{
        return &amp;MockLLM_Call_Call{Call: _e.mock.On("Call",
                append([]interface{}{ctx, prompt}, options...)...)}
}</span>

func (_c *MockLLM_Call_Call) Run(run func(ctx context.Context, prompt string, options ...llms.CallOption)) *MockLLM_Call_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := make([]llms.CallOption, len(args)-2)
                for i, a := range args[2:] </span><span class="cov0" title="0">{
                        if a != nil </span><span class="cov0" title="0">{
                                variadicArgs[i] = a.(llms.CallOption)
                        }</span>
                }
                <span class="cov0" title="0">run(args[0].(context.Context), args[1].(string), variadicArgs...)</span>
        })
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockLLM_Call_Call) Return(_a0 string, _a1 error) *MockLLM_Call_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockLLM_Call_Call) RunAndReturn(run func(context.Context, string, ...llms.CallOption) (string, error)) *MockLLM_Call_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockLLM creates a new instance of MockLLM. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLLM(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockLLM <span class="cov8" title="1">{
        mock := &amp;MockLLM{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
